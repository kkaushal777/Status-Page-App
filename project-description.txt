Build a Simplified Version of a Status Page Application
Objective
 Create a simplified version of a status page application similar to services like StatusPage, Cachet, Betterstack, or Openstatus. The application should allow administrators to manage services and their statuses and provide a public-facing page for users to view the current status of all services.
Project Scope
 The primary goal is to create a working application where anyone can log, view, and manage the status of multiple applications. The application should include a public page where customers and end users can view the status of the application.
Tech Stack
 You are required to use the following technologies:
Frontend: You may choose any front-end framework such as React, or others you are comfortable with.
Backend: Python (Flask)
Database: sqlite3 with an ORM for database interaction.
Authentication: Implement user and team management using SaaS tools like Auth0 for authentication and multi-tenant organization management.
WebSocket: Implement real-time status updates via WebSocket.
UI: Use ShadcnUI for clean, minimalistic design (mandatory).
Submission Guidelines
Provide a GitHub repository with the complete code.
Include a README with setup instructions and any necessary documentation.
Deploy the application to a free hosting service (e.g., Heroku, Vercel, Replit) for easy review.
Create a short Loom video showing the demo of the app and a quick walkthrough of the codebase.
Share a dummy login for testing the submission.
Key Features
User Authentication: Implement secure login functionality.
Team Management: Allow administrators to manage teams within the application.
Organization (Multi-Tenant): Support multiple organizations, each with its own services, incidents, and users.
Service Management:
CRUD Operations: Allow CRUD operations for services (e.g., "Website", "API", "Database").
Status Updates: Enable the ability to set and update the status of each service (e.g., "Operational", "Degraded Performance", "Partial Outage", "Major Outage").
Incident/Maintenance Management:
Create, update, and resolve incidents or scheduled maintenance.
Associate incidents with specific services.
Add updates to ongoing incidents.
Real-Time Status Updates:
Implement WebSocket connections to push status changes to connected clients in real-time.
Public Status Page:
Display the current status of all services.
Show active incidents and maintenance.
Display a timeline of recent incidents and status changes.
Basic Styling
Clean, minimalistic UI similar to Linear. You can use a framework like ShadcnUI.
Optional Stretch Goals (if time permits)
Implement email notifications for status changes.
Add metric graphs for service uptime percentage.
Create a simple API for external status checks.
Evaluation Criteria
Code Quality: Clean, well-organized, and commented code.
Architecture: Proper separation of concerns and scalable design.
Frontend Skills: Responsive design, state management, and component structure.
Backend Skills: API design, database integration, and authentication implementation.
Problem-Solving: How you approach and solve challenges during development.
AI-First Development: Ability to use AI tools like Cursor, GitHub Copilot, Claude Sonnet, etc., to fast-track development.
We look forward to reviewing your innovative solutions and understanding how you approach and solve real-world problems. 

High level design:
High-Level Design of the Status Page Application
Below is a high-level architecture and design outline for your Simplified Status Page Application:

1. User Interaction Flow
Admin/Team User Flow:


Login: Admin logs in via a third-party authentication provider (Auth0 or Clerk).
Dashboard: Admin lands on a dashboard where they can manage services, incidents, and view their organization’s status page.
Service Management: Admin can perform CRUD operations on services (create, edit, delete, change status).
Incident Management: Admin can create, update, resolve incidents, and associate them with specific services.
Real-Time Updates: Admin updates a service’s status, and the WebSocket pushes changes to all connected users (both admins and public users).
Public User Flow:


Public Page View: Public users view the status of services, ongoing incidents, and historical timelines (no login required).
Real-Time Status: The public page automatically updates in real-time as service statuses or incidents change.

2. System Architecture
A. Client-Side (Frontend)
React (Frontend Framework):


Redux (State Management): Manages the global state, such as services, incidents, and user authentication data.
Components:
ServiceListComponent: Displays all services and their statuses (up/down).
IncidentComponent: Displays and manages incidents associated with services.
StatusUpdateComponent: Allows admins to update service statuses.
PublicStatusPage: Displays all services, their statuses, active incidents, and historical data.
TimelineComponent: Displays a timeline of status changes and incidents.
ShadcnUI: For styling, providing a clean, minimalistic UI.
Axios: For making API requests to the Flask backend.
WebSocket (Socket.IO): For real-time updates on service status and incidents.
Routing (React Router):


Admin Routes:
/admin/dashboard: Admin dashboard to manage services, incidents, and teams.
/admin/services: Manage service CRUD operations.
/admin/incidents: Manage incidents and maintenance schedules.
Public Routes:
/status: Public status page showing the current status of services.

B. Server-Side (Backend)
Flask (Backend Framework):


Routes:
/api/login: Handles user authentication (Auth0 or Clerk).
/api/services: Handles service CRUD operations (Create, Read, Update, Delete).
/api/incidents: Handles incident CRUD operations (Create, Read, Update, Resolve).
/api/status: Returns the status of all services for the public page.
WebSocket (Flask-SocketIO):
Used for pushing real-time status updates from the backend to the frontend clients (admins and public).
Authentication:
Handled via Auth0 or Clerk using JWT (JSON Web Tokens).
Role-based Access Control (RBAC) to distinguish between admin and public users.
Database (PostgreSQL):


Tables:
User: Stores information about users, including email, role, and organization association.
Organization: Each user belongs to an organization.
Service: Stores service details (name, status, associated organization).
Incident: Stores incident details (description, status, related service, timestamps).
SQLAlchemy (ORM): Used for interacting with the PostgreSQL database.
Example Schema:


User Table: id, email, password_hash, role, organization_id.
Organization Table: id, name.
Service Table: id, name, status, organization_id.
Incident Table: id, service_id, status, description, resolved, organization_id.
Real-Time Communication:


WebSocket using Flask-SocketIO:
The server broadcasts status updates and incident changes to all connected clients using WebSocket.
When the status of a service or an incident is updated, the backend pushes the change to all connected clients (admins and the public).

3. Key Features and Their Components
A. User Authentication & Role Management
Role-Based Access Control (RBAC):
Admins can manage services and incidents.
Regular users (public) can only view the status page.
Auth0/Clerk Integration:
Auth0 or Clerk handles login, registration, and JWT token issuance.
Each API request requires JWT authentication for secure routes (like service creation, incident creation).
B. Service Management
Service CRUD:
Admins can create, read, update, or delete services.
Each service will have a status (Operational, Degraded, etc.) and may be associated with ongoing incidents.
Use SQLAlchemy ORM to interact with the PostgreSQL database.
C. Incident Management
Incident CRUD:
Admins can create new incidents, associate them with services, and update or resolve them.
Each incident has a status (ongoing, resolved, scheduled).
Admins can add updates to incidents (e.g., "Investigation in Progress").
D. Real-Time Updates
WebSocket (Flask-SocketIO):
Whenever a service status changes or an incident is created/updated, the backend broadcasts this update using WebSocket.
The frontend listens for these updates and automatically updates the UI without needing to refresh the page.
E. Public Status Page
Public View:
A public-facing page where users can view the status of services, ongoing incidents, and historical timelines.
Uses WebSocket for real-time updates to show the latest service status and incident details.
F. Database Interaction (PostgreSQL)
Service & Incident Tracking:
The database stores all service statuses, incident details, and updates.
The database schema is designed to allow each organization to have its own set of services and incidents, supporting multi-tenancy.

4. Component Interaction Overview
Frontend (React):


Initial Load: Fetch services and incidents from the Flask API.
Real-Time Updates: On status or incident change, WebSocket pushes updates to the React frontend, which updates the displayed data.
Backend (Flask):


Admin Actions: When an admin creates a service or an incident, or updates a status, the backend updates the database and emits a WebSocket event to notify connected clients.
Public View: When the public page is accessed, the Flask API sends the current service statuses and incidents.
WebSocket:


Enables real-time communication between the frontend and backend, ensuring that users (both admins and public) are always seeing the latest updates without needing to refresh the page.

5. Data Flow
Admin/Authenticated User Interaction:


Admin interacts with the React frontend to manage services and incidents.
These actions trigger API calls to the Flask backend.
The backend updates the PostgreSQL database and emits WebSocket events with the new status or incident data.
The frontend receives these WebSocket events and updates the UI immediately.
Public User Interaction:


The public accesses the status page where they can see the current status of all services.
Real-time updates via WebSocket ensure the public page is updated instantly when service statuses change.

6. Deployment and Hosting
Frontend Hosting:


Host the React app on Vercel or Netlify.
Backend Hosting:


Host the Flask app with Heroku or Render, both of which support WebSocket functionality.
Use Heroku Postgres for PostgreSQL hosting.
Domain:


Use a custom domain for the public status page.

Conclusion
This high-level design outlines the major components and interactions within the system. It divides the application into frontend, backend, and database parts, ensuring that services, incidents, and user roles are well managed while supporting real-time updates for both admins and public users. You can begin the implementation by setting up the database schema, developing API routes, and integrating the frontend with WebSocket functionality to enable real-time updates.

